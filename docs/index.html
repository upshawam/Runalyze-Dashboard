<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Runalyze Dashboard</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Luxon + Chart.js Luxon adapter (provides the date adapter Chart.js needs for time scales) -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1/dist/chartjs-adapter-luxon.min.js"></script>

  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 24px; }
    #controls { margin-bottom: 12px; }
    canvas { max-width: 1000px; margin-bottom: 28px; }
    .note { color: #666; font-size: 0.9rem; margin-bottom:8px; }
    .error { color: #b00; font-weight: 600; margin-top:6px; }
  </style>
</head>
<body>
  <h1>Runalyze Dashboard (static)</h1>
  <div class="note">If charts are empty, confirm the JSON files exist at <code>/data/&lt;user&gt;_marathon.json</code> and <code>/data/&lt;user&gt;_vo2.json</code>.</div>

  <div id="controls">
    <label>User A: <input id="userA" value="kristin"></label>
    <label>User B: <input id="userB" value="aaron"></label>
    <button onclick="refresh()">Refresh</button>
    <span id="status" style="margin-left:12px;color:#666"></span>
  </div>

  <h2>Marathon shape</h2>
  <canvas id="chartMarathon" height="120"></canvas>

  <h2>VO2max (trend)</h2>
  <canvas id="chartVo2" height="120"></canvas>

  <div id="errors" style="margin-top:12px;"></div>

  <script>
    const statusEl = document.getElementById('status');
    const errorsEl = document.getElementById('errors');

    const ctxM = document.getElementById('chartMarathon').getContext('2d');
    const ctxV = document.getElementById('chartVo2').getContext('2d');

    const chartM = new Chart(ctxM, {
      type: 'line',
      data: { datasets: [] },
      options: {
        parsing: false,
        scales: {
          x: { type: 'time', time: { unit: 'day', tooltipFormat: 'DD LLL yyyy' } },
          y: { beginAtZero: true }
        },
        plugins: { legend: { display: true } }
      }
    });

    const chartV = new Chart(ctxV, {
      type: 'line',
      data: { datasets: [] },
      options: {
        parsing: false,
        scales: {
          x: { type: 'time', time: { unit: 'day', tooltipFormat: 'DD LLL yyyy' } }
        },
        plugins: { legend: { display: true } }
      }
    });

    async function fetchJSON(path) {
      try {
        const r = await fetch(path + '?t=' + Date.now());
        if (!r.ok) {
          const text = await r.text().catch(()=> '');
          throw new Error(`${r.status} ${r.statusText} - ${text.slice(0,200)}`);
        }
        return await r.json();
      } catch (e) {
        throw new Error(`Fetch ${path} failed: ${e.message}`);
      }
    }

    function trendToPoints(trendObj) {
      if (!trendObj) return [];
      const obj = trendObj.data || trendObj.trend || trendObj;

      const entries = Object.entries(obj).map(([k, v]) => {
        // Normalize x
        let x;
        if (/^\d+$/.test(k)) {
          let n = Number(k);
          if (n < 1e12) n = n * 1000; // seconds -> ms
          x = n;
        } else {
          x = k;
        }

        // Normalize y
        let y = null;
        if (typeof v === 'number') {
          y = v;
        } else if (v && typeof v === 'object') {
          if (typeof v.value === 'number') y = v.value;
          else if (typeof v.y === 'number') y = v.y;
          else if (Array.isArray(v) && typeof v[0] === 'number') y = v[0];
          else {
            const num = Object.values(v).find(a => typeof a === 'number');
            if (typeof num === 'number') y = num;
          }
        }

        return { x, y };
      }).filter(pt => pt.y !== null);

      entries.sort((a, b) => {
        const ax = typeof a.x === 'number' ? a.x : String(a.x);
        const bx = typeof b.x === 'number' ? b.x : String(b.x);
        if (ax < bx) return -1;
        if (ax > bx) return 1;
        return 0;
      });

      return entries;
    }

    function showStatus(text) { statusEl.textContent = text; }
    function showError(msg) {
      const el = document.createElement('div');
      el.className = 'error';
      el.textContent = msg;
      errorsEl.appendChild(el);
      console.error(msg);
    }

    async function refresh() {
      errorsEl.innerHTML = '';
      showStatus('Loadingâ€¦');
      const a = document.getElementById('userA').value.trim() || 'kristin';
      const b = document.getElementById('userB').value.trim() || 'aaron';

      const mAPath = `data/${a}_marathon.json`;
      const mBPath = `data/${b}_marathon.json`;
      const vAPath = `data/${a}_vo2.json`;
      const vBPath = `data/${b}_vo2.json`;

      try {
        const [mA, mB, vA, vB] = await Promise.all([
          fetchJSON(mAPath).catch(err => { showError(err.message); return null; }),
          fetchJSON(mBPath).catch(err => { showError(err.message); return null; }),
          fetchJSON(vAPath).catch(err => { showError(err.message); return null; }),
          fetchJSON(vBPath).catch(err => { showError(err.message); return null; })
        ]);

        chartM.data.datasets = [];
        if (mA) chartM.data.datasets.push({ label: a, data: trendToPoints(mA), borderColor: 'steelblue', fill: false });
        if (mB) chartM.data.datasets.push({ label: b, data: trendToPoints(mB), borderColor: 'orange', fill: false });
        chartM.update();

        chartV.data.datasets = [];
        if (vA && vA.trend) chartV.data.datasets.push({ label: a, data: trendToPoints(vA.trend), borderColor: 'green', fill:false });
        if (vB && vB.trend) chartV.data.datasets.push({ label: b, data: trendToPoints(vB.trend), borderColor: 'purple', fill:false });
        chartV.update();

        if ((!mA && !mB) && (!vA && !vB)) showStatus('No data found for selected users.');
        else showStatus('Loaded');
      } catch (e) {
        showError('Unexpected error: ' + e.message);
        showStatus('Error');
      }
    }

    // initial load
    refresh();
  </script>
</body>
</html>
