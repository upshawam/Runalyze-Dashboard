<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VO₂ Max & Marathon Shape Comparison</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>

  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
      margin: 24px;
      background: #fafafa;
      color: #111;
    }

    .page-title { font-size:1.25rem; font-weight:700; margin-bottom:8px; }
    .note { color:#666; font-size:0.95rem; margin-bottom:18px; }

    .chart-wrap { max-width:1200px; margin:28px auto; }
    canvas { width:100% !important; height:380px !important; display:block; background: #fff; border-radius:6px; box-shadow: 0 1px 4px rgba(0,0,0,0.04); }

    h2 { display:flex; align-items:center; gap:12px; justify-content:space-between; margin:0 0 12px 0; }
    .mar-pct { font-size:0.95rem; color:#222; font-weight:700; }
    .status { display: none; } /* hidden as requested */
    .error { color:#b00; font-weight:700; margin-top:8px; text-align:center; }

    /* prognosis table */
    .prog-table { width:100%; max-width:800px; margin:10px auto 0; border-collapse:collapse; background:#fff; border-radius:6px; overflow:hidden; box-shadow:0 1px 4px rgba(0,0,0,0.04); }
    .prog-table th, .prog-table td { padding:8px 10px; border-bottom:1px solid #eee; text-align:left; }
    .prog-table th { background:#f6f8fb; font-weight:700; }
    .prog-header { display:flex; justify-content:space-between; align-items:center; gap:12px; max-width:1200px; margin:0 auto; }

    @media (max-width:700px) {
      canvas { height:300px !important; }
      h2 { flex-direction:column; align-items:flex-start; gap:6px; }
      .prog-table th, .prog-table td { padding:6px 8px; }
    }
  </style>
</head>
<body>
  <div class="page-title">VO₂ Max & Marathon Shape (static)</div>
  <div class="note">Displaying the last 30 days. Data is loaded from data/&lt;user&gt;_vo2.json and data/&lt;user&gt;_marathon.json.</div>

  <div id="errors" class="error" aria-live="polite"></div>
  <div id="status" class="status" aria-live="polite"></div>

  <section class="chart-wrap" aria-labelledby="vo2-title">
    <h2 id="vo2-title">VO₂ Max Trend (last 30 days)</h2>
    <canvas id="vo2Chart" role="img" aria-label="VO2 Max trend chart"></canvas>
  </section>

  <section class="chart-wrap" aria-labelledby="mar-title">
    <div class="prog-header">
      <h2 id="mar-title" style="margin:0">Marathon Shape (last 30 days)</h2>
      <div id="marathonPct" class="mar-pct">Kristin: --% &nbsp;&nbsp; Aaron: --%</div>
    </div>

    <canvas id="marathonChart" role="img" aria-label="Marathon shape chart"></canvas>

    <!-- Prognosis table -->
    <table id="prognosisTable" class="prog-table" aria-label="Prognosis predictions">
      <thead>
        <tr><th>Distance</th><th>Kristin (time / pace)</th><th>Aaron (time / pace)</th></tr>
      </thead>
      <tbody>
        <tr><td colspan="3" style="text-align:center;color:#666">Loading prognosis…</td></tr>
      </tbody>
    </table>
  </section>

<script>
/*
  Minimal dynamic page:
  - Fixed users: kristin and aaron.
  - Loads JSON from data/<user>_vo2.json, data/<user>_marathon.json and data/<user>_prognosis.json
  - Renders VO2 & marathon charts (last 30 days) and a Prognosis table (distance / time / pace for each user).
*/

const errorsEl = document.getElementById('errors');
const statusEl = document.getElementById('status'); // kept for accessibility but hidden visually
const marPctEl = document.getElementById('marathonPct');
const progTbody = document.querySelector('#prognosisTable tbody');

function showError(msg){ errorsEl.textContent = msg || ''; if(msg) console.error(msg); }
function showStatus(msg){ if(statusEl) statusEl.textContent = msg || ''; }

async function fetchJSON(path){
  try{
    const r = await fetch(path + '?t=' + Date.now());
    if(!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return await r.json();
  }catch(e){
    throw new Error(`Fetch ${path} failed: ${e.message}`);
  }
}

function isoToDateKey(iso){
  const d = new Date(iso);
  if(Number.isNaN(d.getTime())) return null;
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth()+1).padStart(2,'0');
  const day = String(d.getUTCDate()).padStart(2,'0');
  return `${y}-${m}-${day}`;
}

function getLastNDates(n){
  const out = [];
  const now = new Date();
  for(let i = n-1; i >= 0; i--){
    const d = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
    d.setUTCDate(d.getUTCDate() - i);
    const key = d.getUTCFullYear() + '-' + String(d.getUTCMonth()+1).padStart(2,'0') + '-' + String(d.getUTCDate()).padStart(2,'0');
    out.push(key);
  }
  return out;
}

function vo2ToMap(vo2json){
  if(!vo2json) return {};
  if(vo2json.trend && typeof vo2json.trend === 'object') return vo2json.trend;
  if(Array.isArray(vo2json.values)){
    const m = {};
    for(const it of vo2json.values){
      if(!it || !it[0]) continue;
      const k = isoToDateKey(it[0]);
      if(k) m[k] = it[1];
    }
    return m;
  }
  if(typeof vo2json === 'object') return vo2json;
  return {};
}
function marathonToMap(mjson){
  if(!mjson) return {};
  if(typeof mjson === 'object') return mjson;
  return {};
}
function buildSeries(map, labels){
  return labels.map(d => {
    const v = map[d];
    return (v === null || v === undefined) ? null : Number(v);
  });
}
function findLatestValue(map){
  const keys = Object.keys(map).sort();
  for(let i = keys.length-1; i >=0; i--){
    const k = keys[i];
    const v = map[k];
    if(v !== null && v !== undefined && !Number.isNaN(Number(v))) return { date: k, value: Number(v) };
  }
  return null;
}

function createOrUpdateChart(ctx, data, options, existing){
  if(existing){
    existing.data = data;
    existing.options = options || existing.options;
    existing.resize();
    existing.update();
    return existing;
  }
  return new Chart(ctx, { type:'line', data, options });
}

const userA = 'kristin';
const userB = 'aaron';

let vo2Chart = null;
let marathonChart = null;

async function loadAndRender(){
  errorsEl.textContent = '';
  showStatus('Loading…');

  try{
    const [vo2Ajson, vo2Bjson, marAjson, marBjson, progAjson, progBjson] = await Promise.all([
      fetchJSON(`data/${userA}_vo2.json`).catch(e=>{ showError(e.message); return null; }),
      fetchJSON(`data/${userB}_vo2.json`).catch(e=>{ showError(e.message); return null; }),
      fetchJSON(`data/${userA}_marathon.json`).catch(e=>{ showError(e.message); return null; }),
      fetchJSON(`data/${userB}_marathon.json`).catch(e=>{ showError(e.message); return null; }),
      fetchJSON(`data/${userA}_prognosis.json`).catch(e=>{ /* no prognosis yet */ return null; }),
      fetchJSON(`data/${userB}_prognosis.json`).catch(e=>{ /* no prognosis yet */ return null; })
    ]);

    const vo2Amap = vo2ToMap(vo2Ajson);
    const vo2Bmap = vo2ToMap(vo2Bjson);
    const marAmap = marathonToMap(marAjson);
    const marBmap = marathonToMap(marBjson);

    const last30 = getLastNDates(30);

    const vo2ASeries = buildSeries(vo2Amap, last30);
    const vo2BSeries = buildSeries(vo2Bmap, last30);
    const marASeries = buildSeries(marAmap, last30);
    const marBSeries = buildSeries(marBmap, last30);

    const latestMarA = findLatestValue(marAmap);
    const latestMarB = findLatestValue(marBmap);

    const pA = latestMarA ? Math.round(latestMarA.value * 100) + '%' : '--%';
    const pB = latestMarB ? Math.round(latestMarB.value * 100) + '%' : '--%';
    const nameA = userA.charAt(0).toUpperCase() + userA.slice(1);
    const nameB = userB.charAt(0).toUpperCase() + userB.slice(1);
    marPctEl.textContent = `${nameA}: ${pA}   ${nameB}: ${pB}`;

    // build chart payloads
    const vo2Data = {
      labels: last30,
      datasets: [
        { label: `${nameA} VO₂`, data: vo2ASeries, borderColor:'rgba(75,192,192,1)', backgroundColor:'rgba(75,192,192,0.12)', tension:0.25, pointRadius:3, spanGaps:true },
        { label: `${nameB} VO₂`, data: vo2BSeries, borderColor:'rgba(255,99,132,1)', backgroundColor:'rgba(255,99,132,0.12)', tension:0.25, pointRadius:3, spanGaps:true }
      ]
    };
    const vo2Opts = { responsive:true, plugins:{legend:{display:true}}, scales:{ x:{ type:'category' }, y:{ beginAtZero:false } }, maintainAspectRatio:false };

    const marData = {
      labels: last30,
      datasets: [
        { label: `${nameA} marathon`, data: marASeries, borderColor:'rgba(20,115,220,1)', backgroundColor:'rgba(20,115,220,0.10)', tension:0.2, pointRadius:3, spanGaps:true },
        { label: `${nameB} marathon`, data: marBSeries, borderColor:'rgba(255,140,0,1)', backgroundColor:'rgba(255,140,0,0.10)', tension:0.2, pointRadius:3, spanGaps:true }
      ]
    };
    const marOpts = { responsive:true, plugins:{legend:{display:true}}, scales:{ x:{ type:'category' }, y:{ beginAtZero:false } }, maintainAspectRatio:false };

    // render or update
    const vo2Ctx = document.getElementById('vo2Chart').getContext('2d');
    const marCtx = document.getElementById('marathonChart').getContext('2d');

    vo2Chart = createOrUpdateChart(vo2Ctx, vo2Data, vo2Opts, vo2Chart);
    marathonChart = createOrUpdateChart(marCtx, marData, marOpts, marathonChart);

    // Render prognosis table
    renderPrognosisTable(progAjson, progBjson);

    // Clear any error text
    showError('');

  }catch(e){
    showError(e.message);
    showStatus('');
  }
}

function renderPrognosisTable(progA, progB){
  // progA/progB are arrays of entries or null
  const aEntries = Array.isArray(progA) ? progA : [];
  const bEntries = Array.isArray(progB) ? progB : [];

  // Build a union of distance_label keys (use label if present, else distance_mi)
  const keys = new Map();
  aEntries.forEach(e => {
    const key = e.distance_label || String(e.distance_mi) + ' mi';
    keys.set(key, key);
  });
  bEntries.forEach(e => {
    const key = e.distance_label || String(e.distance_mi) + ' mi';
    keys.set(key, key);
  });

  // If no prognosis found, show a friendly message
  if(keys.size === 0){
    progTbody.innerHTML = '<tr><td colspan="3" style="text-align:center;color:#666">No prognosis data available (run workflow or fetch manually).</td></tr>';
    return;
  }

  // Sort keys by numeric distance when possible
  const sortedKeys = Array.from(keys.keys()).sort((A,B)=>{
    const numA = parseFloat(A.replace(',', '.').replace(/[^\d\.]/g,'')) || 0;
    const numB = parseFloat(B.replace(',', '.').replace(/[^\d\.]/g,'')) || 0;
    return numA - numB;
  });

  // map distance_label -> entry
  const amap = new Map(aEntries.map(e => [(e.distance_label || String(e.distance_mi) + ' mi'), e]));
  const bmap = new Map(bEntries.map(e => [(e.distance_label || String(e.distance_mi) + ' mi'), e]));

  const rows = sortedKeys.map(k => {
    const a = amap.get(k);
    const b = bmap.get(k);
    const aText = a ? `${a.time || '-'}  (${a.pace || '-'})` : '-';
    const bText = b ? `${b.time || '-'}  (${b.pace || '-'})` : '-';
    return `<tr><td>${k}</td><td>${aText}</td><td>${bText}</td></tr>`;
  });

  progTbody.innerHTML = rows.join('\n');
}

window.addEventListener('load', loadAndRender);
</script>
</body>
</html>
